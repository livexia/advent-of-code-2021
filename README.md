# advent-of-code-2021

## 记录

**Day 14**：

最初的想法是将规则存入一个HashMap，而将聚合物存入列表。对于每一次聚合，遍历聚合物的两个元素，根据元素从规则中找到新的三个聚合元素，并存入新的聚合物列表，遍历结束后再将新的聚合物列表替换原有的聚合物列表。

**复杂度分析：** 这个实现方式的效率极低，因为每次遍历的次数都是前一次的两倍，实际上是一个指数级的增长。那么对于N个元素，M次聚合，第N次需要至少遍历2^n个元素，总共的复杂度应该是 O(M*2^N)。

在无法快速取得结果后，我尝试观察每一次的结果，而花了大量的时间尝试寻找其中的规律。最后我只好求助于社区的答案，于是在twitter上找到了 [dcreemer/adventofcode](https://github.com/dcreemer/adventofcode) 的答案。我根据我看到的解决办法，利用 Rust 写了新的答案。

同样是将规则存入HashMap，但是这次以键是聚合物对，值是聚合物对出现的次数，将聚合物存入HashMap。对于每一次聚合，新建一个与聚合物相同的HashMap，遍历聚合物的两个元素，也就是一个聚合对，根据规则实际上一个聚合对在一次聚合之后，会生成两个新的聚合，那么新生成的两个聚合对的次数也就是旧友聚合对的次数，将新的聚合对和次数存入新的HashMap。每次聚合结束之后，再替换旧的聚合物HashMap为新的HashMap。

**复杂度分析：** 对于输入，总有10个元素，那么总共有100个元素对，对于每次聚合，元素对的总数不变，也就是只需要进行200次的HashMap插入操作。那么对于N个元素，M次聚合，总共的复杂度应该是 O(MN^2) 。这个方法的复杂度较我自己的方法是一个指数时间和二次时间的差别。

**对于计数的复杂度分析：** 利用一个键为元素，值为个数的HashMap来对元素对出现次数进行统计，对于每一次聚合中的每一个聚合对，实际上只是增加了一个元素，那么在这时对HashMap的元素次数加一即可。总共进行 O(2^N) 次HashMap次数更新。

**Day 15**:

使用 Dijkstra 算法。使用 BinaryHeap 和 Reverse 实现一个最小堆，加快遍历速度。

参考：https://oi-wiki.org/graph/shortest-path/#dijkstra

**Day 17:**:

花了很多时间尝试推导出初始速度的范围，~~但是实际上暴力就可以解决了~~，需要进行裁切，具体裁切的过程和分析请看代码注释。（物理的知识完全没有记住）